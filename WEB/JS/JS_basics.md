# Комментарии.

Кроме собственного кода в файлах с исходным кодом могут находиться **комментарии**. Это текст, который не является частью программы и нужен программистам для пометок. 
С их помощью добавляют пояснения, как работает код, какие здесь ошибки нужно поправить или не забыть что-то добавить позже.

### Комментарии в JavaScript бывают двух видов.

**Однострочные** комментарии начинаются с //. 
После этих двух символов может следовать любой текст, вся строка не будет анализироваться и исполняться. Комментарий может занимать всю строку. Если одной строки мало, то создаются несколько комментариев:

`// For Winterfell!`

`// For Lanisters!`

Комментарий может находиться на строке после какого-нибудь кода:

`console.log('I am the King'); // For Lannisters!`

**Многострочные** комментарии начинаются с /* и заканчиваются */.

`/*
  The night is dark and`
  `full of terrors.
*/`
`console.log('I am the King');`

# Инструкции.

**Инструкция** — это команда для компьютера выполнить что-то. 
Код на JavaScript — это **набор инструкций**, которые, как правило, отделяются друг от друга символом **;**.

*Пример кода с двумя инструкциями.*

`console.log('Mother of Dragons.');`

`console.log('Dracarys!');`

`// => Mother of Dragons.`

`// => Dracarys!`

*Инструкции можно написать друг за другом без переноса на новую строку:*

`console.log('Mother of Dragons.'); console.log('Drakarys!');`

***Инструкция** — это единица исполнения.*
***Интерпретатор** (программа, которая запускает код на JavaScript), выполняет инструкции строго по очереди.* 
И мы, как разработчики, должны понимать этот порядок и уметь мысленно разделять программу на независимые части, удобные для анализа.

# Арифметические операции.

* Операторы.
* Коммутативная операция.
* Композиция операций.
* Приоритет операций.

`+ — сложение`

`* — умножение`

`/ — деление`

`- — вычитание`

`% — остаток от деления`

`** — возведение в степень`


*Выведем на экран результат деления, а потом результат возведения в степень:*

`console.log(8 / 2);  // => 4`

`console.log(3 ** 2); // => 9`

### Операторы.

**Оператор** - Знак операции, такой как +
**Операторы выполняют операции над** определенными значениями, которые называются **операндами**.

Сами операторы обычно представлены одним или несколькими символами. Реже словом. Подавляющее большинство операторов соответствуют математическим операциям.

`console.log(8 + 2);`

`В этом примере + — это оператор, а числа 8 и 2 — это операнды.`

Операции, которые требуют наличия двух операндов, называются **бинарными**. Если пропустить хотя бы один операнд, например, 3 + ;, то программа завершится с синтаксической ошибкой.

Операции (не операторы) бывают не только **бинарными**, но и **унарными** (с одним операндом), и даже **тернарными** (с тремя операндами)! Причем операторы могут выглядеть одинаково, но обозначать разные операции.

`console.log(-3); // => -3`

*-3 — это одновременно и число само по себе, и оператор с операндом, но у языков программирования такая структура.*

### Коммутативная операция.

**Коммутативный закон** - от перемены мест слагаемых сумма не меняется.

**Бинарная операция** считается **коммутативной**, если **поменяв местами операнды**, вы получаете **тот же самый результат**. 
Очевидно, что сложение — *коммутативная операция: 3 + 2 = 2 + 3.*

### Композиция операций.

А что, если понадобится вычислить такое выражение: 3 * 5 - 2? 

Именно так мы и запишем:

`console.log(3 * 5 - 2); // => 13`

Обратите внимание, что **интерпретатор производит арифметические вычисления в правильном порядке: *сначала деление и умножение, потом сложение и вычитание.***

Интерпретатор соединяет сложные составные выражения, последовательно выполняя заложенные в них арифметические действия, по умолчанию соблюдая правильный порядок: *сначала умножение и деление, затем — сложение и вычитание.*

### Приоритет операций.

Нередко вычисления должны происходить в порядке, отличном от стандартного приоритета. 

В сложных ситуациях **приоритет нужно задавать круглыми скобками**, точно так же, как в школе, например: (2 + 2) * 2.

Скобки можно ставить вокруг любой операции. Они могут вкладываться друг в друга сколько угодно раз. Вот пара примеров:

`console.log(3 ** (4 - 2)); // => 9`

`console.log(7 * 3 + (4 / 2) - (8 + (2 - 1))); // => 14`

Иногда выражение сложно воспринимать визуально. Тогда можно расставить скобки, не повлияв на приоритет. Например:

Было:

`console.log(8 / 2 + 5 - -3 / 2); // => 10.5`

Стало:

`console.log(((8 / 2) + 5) - (-3 / 2)); // => 10.5`

# Ошибки оформления (синтаксиса и линетра).

* Ошибка синтаксиса.
* Ошибки линтера.

### Ошибка синтаксиса.
**Синтаксическая ошибка** возникает в том случае, когда **код был записан с нарушением грамматических правил**. 

Любое мельчайшее нарушение, и программа даже не запустится. Примером может быть забытая **;**, неправильно расставленные скобки и другие детали.

*Вот пример кода с синтаксической ошибкой:*

`console.log('Hodor'`

Если запустить код выше, то мы увидим следующее сообщение: 
`SyntaxError: missing ) after argument list`, 
а также указание на строку и файл, где возникла эта ошибка. 
*Подобные синтаксические ошибки в JavaScript относятся к разряду **SyntaxError.***

С одной стороны, ошибки **SyntaxError** — самые простые, потому что они связаны исключительно с грамматическими правилами написания кода, а не с самим смыслом кода. Их легко исправить: нужно лишь найти нарушение в записи.

С другой стороны, интерпретатор не всегда может четко указать на это нарушение. Поэтому бывает, что забытую скобку нужно поставить не туда, куда указывает сообщение об ошибке.

### Ошибки линтера.

**Линтер отвечает за форматирование кода. Необходим для человека.**


**Код программы следует оформлять определенным образом**, чтобы он был достаточно **понятным и простым в поддержке.**

Специальные наборы правил — **стандарты** — **описывают различные аспекты написания кода.** 
*Таких стандартов несколько, самые известные в JavaScript:* **AirBnb, Standard, Google.**

В любом языке программирования существуют *утилиты* — так называемые **линтеры**. 
Они проверяют код на соответствие стандартам. В JavaScript это *eslint.*

*Взгляните на пример из предыдущего урока:*

`console.log(8/2+5 - -3 / 2); // => 10.5`

Линтер будет «ругаться» на нарушение сразу нескольких правил:

* space-infix-ops – Отсутствие пробелов между оператором и операндами.
* no-mixed-operators – По стандарту нельзя писать код, в котором разные операции используются в одном выражении без явного разделения скобками.

# Строки

* Кавычки.
* Экранирующие последовательности.
* Конкатенация.


### Кавычки.

Какие из этих пяти вариантов — строки?

`'Hello'` - строка

`'Goodbye'`- строка

`'G'`- строка

`' '`- строка

`''`- строка


*Любой одиночный символ в кавычках* — это строка. 
*Пустая строка* — это тоже строка. 
То есть строкой мы считаем *все, что находится внутри кавычек*, *даже если это пробел, один символ или вообще отсутствие символов.*

Строки можно записывать в двойных кавычках:

`// Стандарт кодирования airbnb, рекомендует`

`// использовать, по возможности, одинарные`

`console.log('Dracarys!');`

Напечатаем строчку *Dragon's mother*. 
Апостроф перед буквой s — это такой же символ, как одинарная кавычка. 

Попробуем:

`console.log('Dragon's mother');`

`// Uncaught SyntaxError: missing ) after argument list`

Этот код синтаксически некорректен.

Здесь нам помогут двойные кавычки. Такой вариант программы отработает корректно:

`console.log("Dragon's mother");`

Чтобы создать строку:
*Dragon's mother said "No"*

Используют **экранирование специальных символов**.
Для экранирования используется обратный слеш \

`// Экранируется только ", так как в этой ситуации`

`// двойные кавычки имеют специальное значение`

`console.log("Dragon's mother said \"No\"");`

`// => Dragon's mother said "No"`

Чтобы вывести сам обратный слеш, необходимо точно так же, как и любой другой специальный символ, экранировать самим собой.

`console.log("\\");`

`// => \`

### Экранирующие последовательности.

*Мы хотим показать диалог Матери Драконов со своим ребенком:*

`- Are you hungry?`

`- Aaaarrrgh!`

Если вывести на экран строку с таким текстом:

`console.log('- Are you hungry?- Aaaarrrgh!');`

то получится так:

`- Are you hungry?- Aaaarrrgh!`

Чтобы перенести строку ниже другой, необходимо сделать перевод строки с помощью символа перевода строки: **\n.**

`console.log('- Are you hungry?\n- Aaaarrrgh!');`

`- Are you hungry?`

`- Aaaarrrgh!`

**\n** - это один невидимый символ перевода строки.

**\n** — это пример **экранирующей последовательности** (escape sequence). Их еще называют управляющими конструкциями.

1. **Не имеет значения, что стоит перед или после \n: символ или пустая строка. Перевод будет обнаружен и выполнен в любом случае**

`console.log('Gregor Clegane\nDunsen\nPolliver\nChiswyck');`

На экран выведется:

`Gregor Clegane`

`Dunsen`

`Polliver`

`Chiswyck`


2. **Помните, что строка может содержать один символ или вообще ноль символов. А еще строка может содержать только \n**

*console.log()* при выводе значения автоматически добавляет в конец символ перевода строки. 
Таким образом, один перевод строки мы можем указать явно, передав этот символ экранирующей последовательности аргументом в функцию, а второй перевод строки добавить самой функцией автоматически.

`console.log('Polliver');`

`console.log('Gregor Clegane');`

`console.log();`

`console.log('Chiswyck');`

`console.log('\n');`

`console.log('Dunsen');`

`// => Polliver`

`// => Gregor Clegane`

`// =>`

`// => Chiswyck`

`// =>`

`// =>`

`// => Dunsen`

3. **Если нам понадобится вывести \n именно как текст (два отдельных печатных символа), то можно воспользоваться уже известным нам способом экранирования, добавив еще один \ в начале. То есть последовательность `\\`n отобразится как символы \ и n, идущие друг за другом.**

`console.log('Joffrey loves using \\n');`

`// => Joffrey loves using \n`

### Конкатенация.

В веб-разработке программы постоянно оперируют строками. Все, что мы видим на сайтах, так или иначе представлено в виде текста. Этот текст чаще всего динамический, то есть полученный из разных частей, которые соединяются вместе. 

**Конкатенация** - операция соединения строк в программировании.

`// Оператор такой же, как и при сложении чисел`

`// но здесь он имеет другой смысл (семантику)`

`console.log('Dragon' + 'stone');`

`// => Dragonstone`

*Cтроки можно склеивать, даже если они записаны с разными кавычками.*

King's Landing нужно писать через пробел. Но в наших начальных строках не было пробелов, а пробелы в самом коде слева и справа от символа + не имеют значения, потому что они не являются частью строк.

*Выхода из этой ситуации два:*

`/ Оба способа равнозначны`

`// Ставим пробел в левой части`
`console.log("King's " + 'Landing');` 
`//  => King's Landing`


`// Ставим пробел в правой части`
`console.log("King's" + ' Landing'); `
`//  => King's Landing`

*Пробел — такой же символ, как и другие. Чем больше пробелов, тем шире отступы:*

`console.log("King's " + ' Landing');`   
`// => King's  Landing`

`console.log("King's  " + '  Landing');` 
`// => King's    Landing`


# Переменные.

* Изменение переменной.
* Ошибки при работе с переменными.
* Константы.

**Переменная** указывает на данные, которые были в нее записаны. 

Благодаря этому, данные можно использовать многократно без необходимости их постоянно дублировать.

*Мы объявляем переменную с необходимой нам фразой.*

Сама переменная создается и наполняется данными (инициализируется) **с помощью инструкции**

`let greeting = 'Father!'.`

`let` - Ключевое слово для создание переменной.

`greeting` - Имя переменной.

`=` - Оператор присваивания.

`Father!` - Значение.

Для **имени переменной** используется **любой набор допустимых символов, к которым относятся буквы английского алфавита, цифры, а также знаки _ и $.** При этом цифру **нельзя ставить в начале.** Имена переменных регистрозависимы, то есть **имя hello и имя heLLo – это два разных имени, а значит и две переменные.**

**Переменную** не обязательно **инициализировать данными во время объявления.** 
Иногда бывает нужно ее создать, а наполняться она будет потом.

**Объявленная, но не инициализированная** переменная, содержит внутри себя **значение undefined**. Это специальное значение, используемое тогда, когда **ничего не определено.**

`let greeting;`

`// Использование`

`console.log(greeting); // undefined`

Для удобства анализа программы, переменные принято создавать как можно ближе к тому месту, где они используются.

### Изменение переменной.

`let greeting = 'Father!';`

`console.log(greeting); // => Father!`

`greeting = 'Mother!'; // => изменили переменную`

`console.log(greeting); // => Mother!`

Имя осталось тем же, но внутри другие данные. 
Обратите внимание на ключевое **различие между объявлением переменной и ее изменением**. 
Ключевое слово **let** ставится **только при создании переменной**, но при изменении оно уже не используется.

#### Ошибки при работе с переменными.

Порядок следования инструкций в коде с переменными имеет огромное значение.
**Переменная должна быть определена до того, как будет использована**.

`// Uncaught ReferenceError: greeting is not defined`

`console.log(greeting);`

`let greeting = 'Father!';`

*ReferenceError: greeting is not defined*. 
*ReferenceError* – это ошибка обращения, она означает, что в коде используется имя (говорят идентификатор), которое не определено.

Кроме неправильного порядка определения, в JavaScript встречаются банальные опечатки — как при использовании переменной, так и при ее объявлении.

Количество подобных ошибок уменьшается за счет использования правильно настроенного редактора. Такой редактор подсвечивает имена, которые используются без объявления, и предупреждает о возможных проблемах.

Еще одна распространенная ошибка — **попытаться объявить уже объявленную переменную:**

`let greeting = 'Father!';`

`let greeting = 'Father!';`

Так делать нельзя. Придется **создать новую переменную.**

### Константы.

**Константа** - указывает на данные, которые были в нее записаны, но значение константы менять нельзя.

Если значение не меняется, то мы имеем дело с *константой*

`const dollarsInEuro = 1.25;`

`const rublesInDollar = 60;`


`const euros = 1000;`


`const dollars = euros * dollarsInEuro;    // 1250`

`const rubles = dollars * rublesInDollar; // 75000`


`console.log(rubles); // => 75000`

Единственное **изменение** заключается в том, что **ключевое слово let заменилось на const**, но это только синтаксис. 
Теперь, если **попытаться изменить любую константу**, то мы получим **сообщение об ошибке.** 
В остальном они используются точно так же, как и переменные.

Константы значительно проще для анализа, когда мы видим константу в коде, то нам сразу понятно, что ее значение всегда остается прежним. При использовании констант отсутствует понятие времени. С переменными все не так, мы не можем быть уверены в их значении, приходится анализировать весь код, чтобы понять, как они могли измениться.

Переменные жизненно необходимы только в одном случае (во всех остальных гарантированно можно обойтись без них) – при работе с циклами.

# Выражения в определениях.

Переменные полезны не только для хранения и переиспользования информации, но и для упрощения сложных вычислений. 

`let dollarsCount = 50 * 1.25; // => после = выражение`

`console.log(dollarsCount); // => 62.5`

**Любая строка — выражение.** 
**Конкатенация строк — тоже выражение.** 
Когда интерпретатор видит выражение, он обрабатывает его и генерирует результат — **значение выражения.**

Правила построения кода (грамматика языка) таковы, что в тех местах, где ожидается выражение, можно поставить любое вычисление (не только математическое, но и, например, строковое — как конкатенация), и программа останется работоспособной.

Запишем стоимость доллара в рублях как отдельную переменную. 
Вычислим цену 50 евро в долларах, умножив их на 1.25. Допустим, что 1 доллар — 60 рублей:

`let rublesPerDollar = 60;`

`let dollarsCount = 50 * 1.25; // 62.5`

`let rublesCount = dollarsCount * rublesPerDollar; // 3750`

`console.log(rublesCount);`

А теперь давайте добавим к выводу текст с помощью конкатенации:

`let rublesPerDollar = 60;`

`let dollarsCount = 50 * 1.25; // 62.5`

`let rublesCount = dollarsCount * rublesPerDollar; // 3750`


`console.log('The price is ' + rublesCount + ' rubles');`

`// => The price is 3750 rubles`

Любая переменная может быть частью любого выражения. В момент вычисления, вместо имени переменной подставляется ее значение.

Интерпретатор вычисляет значение rublesCount до того, как эта переменная начнет использоваться в других выражениях. Когда подходит момент использования переменной, Javascript «знает» значение, потому что уже вычислил его.

# Переменные и конкатенация.

`let what = 'Kings' + 'road';`

`console.log(what); // => Kingsroad`

Конкатенация строки и одной переменной, в которой записана строка:

`let first = 'Kings';`

`let what = first + 'road';`


`console.log(what); // => Kingsroad`

Конкатенация двух переменных, в которых записаны строки:

`let first = 'Kings';`

`let last = 'road';`


`let what = first + last;`

`console.log(what); // => Kingsroad`

# Именование.

* Стили именования
* Магические числа

Мы гораздо чаще читаем код, чем пишем. Причем не свой, а написанный другими людьми. От качества и понятности имен переменных зависит половина успеха в анализе кода.

Лучше посидеть и придумать название, которое описывает суть, смысл переменной, чем назвать ее как попало, а в будущем переделывать. Постарайтесь давать им такие имена, чтобы они были максимально понятны без контекста, без изучения окружающего кода.

Существует общепринятое правило: не используйте транслит для имен, только английский язык. 

### Стили именования.

*greeting* — пример простого имени, но не все имена так просты. 
Довольно часто они составные, то есть включают в себя несколько слов. Например, «имя пользователя». 
В разных языках применяются разные стили кодирования, и имя переменной будет отличаться.

В именовании переменных можно выделить **четыре основных подхода, которые иногда комбинируют друг с другом.** 
Все эти подходы проявляют себя, когда имя переменной состоит из нескольких слов:

**kebab-case** — составные части переменной разделяются дефисом. Например:*my-super-var.*

**snake_case** — для разделения используется подчеркивание. Например: *my_super_var.*

**CamelCase** — каждое слово в переменной пишется с заглавной буквы. Например: *MySuperVar.*

**lowerCamelCase** — каждое слово в переменной пишется с заглавной буквы, кроме первого. Например: *mySuperVar.*

В Javascript используется **CamelCase** и его вариация **lowerCamelCase**, при котором первая буква первого слова — строчная. 
Именно **lowerCamelCase** применяется для переменных. 
Это значит, что имена соединяются друг с другом, при этом все имена кроме первого становятся с заглавной буквы: *userName*. 
С тремя словами это выглядит так: *mySuperVariable.*

### Магические числа.

**Magic Numbers (магические числа)** - Числа, происхождение которых невозможно понять без глубокого знания происходящего внутри данного участка кода.

`let dollarsCount = 50 * 1.25; // 62.5 // Что за число 1.25?`

`let rublesCount = dollarsCount * 60; // 3750 // Что за число 60?`

`console.log(rublesCount);`

Достаточно создать переменные с правильными именами.

`let dollarsPerEuro = 1.25;`

`let rublesPerDollar = 60;`

`let dollarsCount = 50 * dollarsPerEuro; // 62.5`

`let rublesCount = dollarsCount * rublesPerDollar; // 3750`


`console.log(rublesCount);`

**Обратите внимание на следующие детали:**

* Именование **lowerCamelCase.**
* Две новые переменные отделены от последующих вычислений пустой строчкой. Эти переменные имеют смысл и без вычислений, поэтому такое отделение уместно, оно повышает читаемость.
* Получился хорошо именованный и структурированный код, но он длиннее прошлой версии. Так часто бывает, и это нормально. **Код должен быть читабельным.**


# Интерполяция.

`const firstName = 'Joffrey';`

`const greeting = 'Hello';`

`// Обратите внимание на ограничители строки, это бектики` - ``  

`// Интерполяция не работает с одинарными и двойными кавычками`

console.log(`${greeting}, ${firstName}!`);

`// => Hello, Joffrey!`

Мы просто создали одну строку и «вставили» в нее в нужные места константы с помощью знака доллара и фигурных скобок **${ }**. 
Получился как будто бланк, куда внесены нужные значения. И нам не нужно больше заботиться об отдельных строках для знаков препинания и пробелов — все эти символы просто записаны в этой строке-шаблоне. 
В одной строке можно делать сколько угодно подобных блоков.

**Интерполяция** работает только **со строками в бектиках**. **Это символ `.**

**Почти во всех языках интерполяция предпочтительнее конкатенации для объединения строк.** 
Строка при этом получается склеенная, и внутри нее хорошо просматриваются пробелы и другие символы. 

Во-первых, интерполяция позволяет не путать строки с числами (из-за знака +), а во-вторых, так гораздо проще (после некоторой практики) понимать строку целиком.

# Извлечение символов из строки.

Иногда нужно получить один символ из строки. Например, если сайт знает имя и фамилию пользователя, и в какой-то момент требуется вывести эту информацию в формате A. Ivanov, то нужно взять первый символ из имени.

`const firstName = 'Tirion';`

`console.log(firstName[0]); // => T`

**Квадратные скобки с цифрой** — это специальный синтаксис извлечения символа из строки. 
**Цифра называется индексом** — позицией символа внутри строки. 
**Индексы начинаются с 0 почти во всех языках программирования** — поэтому, чтобы получить первый символ, нужно указать индекс 0. 
**Индекс последнего элемента равен длине строки минус единица:**

`// Длина строки 6, поэтому последний индекс — это 5`

`const firstName = 'Tirion';`

`console.log(firstName[5]); // => n`

`const magic = '\nyou';`

`console.log(magic[1]); // => y`

**Индексом может быть не только конкретное число, но и значение переменной.**
Вот пример, который приведет к тому же результату — выводу на экран символа T, но индекс внутри квадратных скобок записан **не числом, а константой:**

`const firstName = 'Tirion';`

`const index = 0;`

`console.log(firstName[index]); // => T`

Технически можно указать индекс и за пределами слова. Для нашего примера — это числа от 6. 
JavaScript не считает такое поведение ошибкой. 
Обращение по несуществующему индексу вернет значение **undefined**.

`const firstName = 'Tirion';`

`console.log(firstName[10]); // => undefined`


# Типы данных.

* undefined
* Числа с плавающей точкой
* Явное преобразование типов

Если мы попробуем умножить число на строку, JavaScript вернет NaN (Not a number - не число) — то самое значение. Оно возникает там, где вместе используются несовместимые значения. В данном случае число и строка:

`3 * 'Dracarys'; // NaN`

Данные разделяются по типам. 
Любая **строка** относится к типу **String**, а **числа** — к типу **Number** и **BigInt** (очень большие числа). 
Типы нужны для защиты программы от трудноуловимых ошибок. **Типы определяют две вещи:**

* Возможные (допустимые) значения. 
Например, числа в JavaScript делятся на два типа: Number и BigInt. 
**Первые** — это все числа ниже определенного порога (его можно посмотреть), **вторые** — выше. 
Такое разделение связано с техническими особенностями работы аппаратуры.

* Набор операций, которые можно выполнять над этим типом. Например, операция умножения имеет смысл для типа «целые числа». 
Но не имеет смысла для типа «строки»: умножать слово «мама» на слово «блокнот» — бессмыслица.

JavaScript ведет себя двояко, когда встречается с нарушениями. В некоторых ситуациях он ругается на недопустимость операции и завершается с ошибкой. В других — программа продолжает работать. В этом случае недопустимая операция возвращает что-то похожее на **NaN**, как в примере выше.

Каким образом JavaScript понимает, что за тип данных перед ним? 
Любое значение где-то инициализируется и, в зависимости от способа инициализации, становится понятно, что перед нами. Например, **числа — это просто числа без дополнительных символов, кроме точки для рациональных чисел.** 
А вот **строки** всегда ограничены **специальными символами** (в JavaScript три разных варианта). 
Например, такое значение '234' – строка, несмотря на то, что внутри нее записаны цифры.

JavaScript позволяет узнать тип данных с помощью оператора **typeof**:

`typeof 3;      // number`

`typeof 'Game'; // string`

Типы данных **Number**, **BigInt** и **String** — это примитивные типы. Но есть и другие. В JavaScript встроен составной тип Object (а на его базе массивы, даты и другие). С его помощью можно объединять данные разных типов в одно значение, например, мы можем создать пользователя, добавив к нему имя и возраст:

`// Этот синтаксис изучается далее на Хекслете`

`const user = { name: 'Toto', age: 33 };`

По-английски строки в программировании называются **"strings"**, а строчки текстовых файлов — **"lines"**. 
Например, в коде выше есть две строчки (lines), но только одна строка (string). 
В русском иногда может быть путаница, поэтому во всех уроках мы будем говорить строка для обозначения типа данных «строка», и строчка для обозначения строчек (lines) в файлах.

### undefined

Объявление переменных возможно и без указания конкретного значения. Что будет выведено на экран, если ее распечатать:

`let name;`

`console.log(name); // ?`

На экране появится **undefined**, специальное значение особого типа, которое означает **отсутствие значения**. 

Undefined активно используется самим JavaScript в самых разных ситуациях, например, при обращении к несуществующему символу строки:

`const name = 'Arya';`

`console.log(name[8]);`

**Смысл** (семантика) значения **undefined** именно в том, что **значения нет**. Однако, ничто не мешает написать такой код:

`let key = undefined;`

И хотя интерпретатор позволяет такое сделать, это нарушение семантики значения undefined, ведь в этом коде выполняется присваивание, а значит — **подставляется значение**.

JavaScript — один из немногих языков, в которых в явном виде присутствует понятие undefined. В остальных языках его функцию выполняет значение null, которое, кстати, тоже есть в JavaScript.

Вопрос на самопроверку. Почему нельзя объявить константу без указания значения?

**Так как константу невозможно изменить.**

### Числа с плавающей точкой

В математике существуют разные виды чисел, например, натуральные – это целые числа от одного и больше, или рациональные – это числа с точкой, например 0.5. С точки зрения устройства компьютеров, между этими видами чисел – пропасть. Попробуйте ответить на простой вопрос, сколько будет 0.2 + 0.1? А теперь посмотрим, что на это скажет JavaScript:

`0.2 + 0.1 // 0.30000000000000004`

Операция сложения двух рациональных чисел внезапно привела к неточному вычислению результата. Тот же самый результат выдадут и другие языки программирования. Такое поведение обуславливается ограничениями вычислительных мощностей. Объем памяти, в отличие от чисел, конечен (бесконечное количество чисел требует бесконечного количества памяти для своего хранения).

Рациональные числа не выстроены в непрерывную цепочку, между 0.1 и 0.2 бесконечное множество чисел. Соответственно возникает серьезная проблема, а как хранить рациональные числа? Это интересный вопрос сам по себе. В интернете множество статей, посвященных организации памяти в таких случаях. Более того, существует стандарт, в котором описано, как это делать правильно, и подавляющее число языков на него опирается.

Для нас, как для разработчиков, важно понимать, что операции с плавающей точкой неточны (эту точность можно регулировать), а значит при решении задач, связанных с подобными числами, необходимо прибегать к специальным трюкам, которые позволяют добиться необходимой точности.

### Явное преобразование типов.

В программировании регулярно встречаются задачи, когда один тип данных нужно преобразовать в другой — например, при работе с формами на сайтах. 
Данные формы всегда приходят в текстовом виде, даже если значение — число. 
Вот как его можно преобразовать:

`const number = parseInt('345');`

`console.log(number); // => 345`

**parseInt()**— это функция, в которую передается значение, чтобы его преобразовать. 
Функция ведет себя подобно арифметическим операциям, но делает особые действия. Вот еще несколько примеров:

`const value = '0';`

`// Внутри скобок можно указывать переменную`

`const number1 = parseInt(value);`

`console.log(number1); // => 0`

`// Или конкретное значение`

`const number2 = parseInt('10');`

`console.log(number2); // => 10`

`// Если преобразуется число с плавающей точкой`

`// то отбрасывается вся дробная часть`

`const number5 = parseInt(3.5);`

`console.log(number5); // => 3`

Точно так же можно **преобразовать строку в число с плавающей точкой с помощью parseFloat():**


`const value3 = parseFloat('0.5');`

`console.log(value3); // 0.5`

# Неизменяемость и примитивные типы.

Что произойдет, если попытаться изменить символ в строке?

`let firstName = 'Alexander';`

`// Код выполнится без ошибок`

`firstName[0] = 'B';`

`console.log(firstName); // => Alexander`

Как это ни странно, но значение переменной *firstName* останется прежним, хотя код выполнится без ошибок. 
Так происходит из-за **неизменяемости примитивных типов** в JavaScript — **язык не дает никакой физической возможности поменять строку.** 
Неизменяемость примитивных типов важна по многим причинам, ключевая — **производительность**. Но что делать, если нам действительно нужно ее изменить? 
**Для этого и существуют переменные:**

`let firstName = 'Alexander';`

`// Код выполнится без ошибок`

`firstName = 'Blexander';`

`console.log(firstName); // => Blexander`

Есть большая **разница между изменением значения переменной и изменением самого значения.** 
**Примитивные типы в JavaScript поменять нельзя, а заменить значение переменной — без проблем.**

### Слабая типизация.

Нам известно про два разных типа данных: **числа и строки**. Мы, например, можем складывать числа, потому что операция сложения — **это операция для типа «числа»**.

А что, если применить эту операцию не к двум числам, а к числу и строке?

`console.log(1 + '7'); // => 17`

Несмотря на то, что '7' — это строка, а не число, интерпретатор JavaScript выдал ответ 17, как если бы мы складывали две строки. 
**Когда JavaScript видит несоответствие типов, он сам пытается преобразовать информацию.** 
В данном случае он **преобразовал** число 1 в строку '1', а потом спокойно сделал **конкатенацию** '1' и '7'.

Не все языки так делают. 
JavaScript — это язык со **слабой типизацией**. 
Он знает о существовании разных типов (числа, строки и др.), но относится к их использованию не очень строго, пытаясь преобразовывать информацию, когда это кажется разумным. Иногда JavaScript даже доходит до крайностей. Большинство выражений, не работающих в других языках, прекрасно работают в JavaScript. 
Попробуйте выполнить любую арифметическую операцию (кроме сложения), подставив туда строки или любые другие типы данных (кроме ситуации, когда оба операнда – это числа или строки, содержащие только число) — вы увидите, что они всегда будут работать и возвращать NaN, что довольно логично.

`const result = 'one' * 'two';`

`console.log(result); // => NaN`


В языках со строгой типизацией сложить число со строкой не получится.

JavaScript был создан для интернета, а в интернете вся информация — это строки. Даже когда вы вводите на сайте номер телефона или год рождения, на сервер эта информация поступает не как числа, а как строки. Поэтому авторы языка решили, что автоматически преобразовывать типы — правильно и удобно.

Такое автоматическое неявное преобразование типов с одной стороны и правда удобно. Но на практике это свойство языка создает множество ошибок и проблем, которые трудно найти. Код может иногда работать, а иногда не работать — в зависимости от того, «повезло» ли в конкретном случае с автоматическим преобразованием. Программист это заметит не сразу.

Слабая типизация красной нитью проходит сквозь всю разработку на Javascript.

# Функции и их вызов.

* Резюме
* Математические функции в JavaScript

Сложение, конкатенация, нахождение остатка от деления и остальные рассмотренные операции – все это довольно базовые возможности языков программирования. 
Математика не ограничена арифметикой, кроме нее есть и множество других разделов со своими операциями, например, геометрия. 
**То же самое касается и строк: их можно переворачивать, менять регистр букв, удалять лишние символы — и это только самое простое.** 
**И, наконец, на более высоком уровне есть прикладная логика конкретного приложения.**
Программы списывают деньги, считают налоги, формируют отчеты. Количество подобных операций бесконечно и индивидуально для каждой программы. И все они должны быть как-то выражены в коде.

Для **выражения любой произвольной операции в программировании** существует понятие **функция**. 
**Функции** бывают как **встроенные**, так и **добавленные** программистом. 
**С одной встроенной функцией мы уже знакомы, это console.log().**

**Функции** — одна из ключевых конструкций в программировании, без них невозможно сделать практически ничего. 
Знакомство с ними мы начинаем как можно раньше, так как весь дальнейший материал оперирует функциями по максимуму. Сначала мы научимся пользоваться уже созданными функциями, а уже потом — создавать свои собственные.

**Начнем с простых функций для работы над строками.** 
Ниже пример вызова функции **length()**, которая считает **количество символов в строке**:

`// length это функция`

`import { length } from './hexlet-basics/string.js';`

`// Вызов функции length с параметром 'Hello!'`

`const result = length('Hello!');`

`console.log(result); // => 6`

Первая строчка в этом коде – импорт функции из другого модуля. Импорты и модули изучаются в других курсах, здесь же они будут присутствовать в задании «как есть», так как без них невозможно использовать функции, определенные в других файлах. Не заморачивайтесь, если вам не понятен смысл происходящего, мы разберем эту тему позже.

**Параметры (или аргументы)** — это **информация, которую функция получает при вызове**. Именно на основе этой информации функция, как правило, вычисляет что-то и выдает результат.

Мы создали **константу result** и указали **интерпретатору записать в нее результат, возвращаемый функцией length() при ее вызове.** В этом смысле функции подобны операциям – они **всегда возвращают результат своей работы.**

`// Вызов length возвращает результат (длину строки)`

`// который записывается в константу с именем result`

`const result = length('Hello!');`

Запись length('Hello!') означает, что **вызывается функция с именем length, в которую был передан параметр 'Hello!'**. **Функция length() считает длину именно той строки, которая ей была передана.**

**Вызов функции всегда обозначается скобками ()**, идущими сразу за именем функции. 
В скобках может быть **любое количество параметров**, **а иногда — вообще ни одного.**
Количество зависит от используемой функции. 
Возьмем для примера **функцию pow()**, которая возводит указанное число в нужную степень.
**Она принимает на вход два параметра и возводит число, переданное первым параметром, в степень, переданную вторым параметром.**

`import { pow } from './math.js';`

`// Вызов pow(2, 3) возвращает значение 2 в 3 степени`

`const result = pow(2, 3); // 2 * 2 * 2`

`console.log(result); // => 8`

**По большому счету, операторы и функции — это одно и то же.** 
**Ключевая разница только в том, как они записываются.**
Если представить (гипотетически) сложение как функцию, то она будет выглядеть так:

`// Обычное сложение`

`3 + 5; // 8`

`// Сложение, представленное как функция`

`// Выглядит странновато, но передает смысл функций`

`+(3, 5);`

### Резюме

**Функции вызываются и возвращают результат, который затем может быть использован в дальнейших вычислениях или, например, выведен на экран.**

**Вопрос на самопроверку.** Как узнать, что возвращает вызов функции console.log()?

**Функции console.log() выводит на экран тот параметр, который мы в нее передаем.**

### Математические функции JavaScript

Объяснение функций в JavaScript немного осложняется структурой языка. Изначально он появился в браузерах и имел сильно ограниченные возможности по сравнению с языками общего назначения. Со временем все изменилось — JavaScript стал мощным языком, захватившим клиентскую разработку и активно использующимся на сервере. Однако наследие осталось, так как нужно поддерживать обратную совместимость. Поэтому в некоторых местах есть несостыковки, которые нельзя объяснить системой: на них можно только махнуть рукой и сказать: «Так исторически сложилось».

К подобным «местам» относятся математические функции. В предыдущем задании мы использовали **самописную функцию pow()** (мы, как создатели курса, добавили ее в практику), а теперь давайте рассмотрим ее версию, встроенную в сам язык.

`Math.pow(2, 3); // 8`

**Что такое Math?** 
**Технически — это объект, доступный из любого места программы**, но перед тем, как говорить об объектах, нужно проделать очень большой путь. 
Сейчас достаточно запомнить, что **функции для математических операций вызываются через Math..** Наличие этой приставки никак не влияет на понятие функции, которое мы рассмотрели ранее и будем рассматривать позже.

**Задание:**

`const fruitsCount = -2309;`

`const result = Math.abs(-2309);`

`console.log(result);`

**Второе решение:**

`const fruitsCount = -2309;`

`console.log(Math.abs(fruitsCount));`

# Сигнатура функций

**Функция Math.pow()**, возводящая число в какую-нибудь степень, **принимает два параметра:** 
**какое число возводить и в какую степень возводить.** 
Если вызывать pow() без параметров, то вернется NaN. Функция честно пытается выполнить возведение в степень, но если значение не передано, то интерпретатор автоматически передает ей undefined. 

JavaScript заставляет программистов быть более аккуратными. В большинстве языков, если передать в функцию меньше параметров, чем она ожидает, то возникнет ошибка, — но только не в JavaScript. NaN вернется и при передаче любых нечисловых значений:

`const result = Math.pow(2, 'boom');`
`console.log(result); // => NaN`

Другая функция может иметь другое число параметров и другие типы параметров. 
Например, может существовать функция, которая принимает три параметра: число, строку и еще одно число.

**Откуда мы знаем, сколько каких параметров нужно функции Math.pow() и какого типа будет «возврат»?** 
Мы заглянули в **сигнатуру этой функции.** Сигнатура определяет входные параметры и их типы, а также выходной параметр и его тип. 

**Про функцию Math.pow() можно почитать в документации. В разделе «Синтаксис» есть такой текст:**

Math.pow(base, exponent)

Параметры
    base
        Основание степени.
    exponent
        Показатель степени, в которую возводится основание base.

Это сигнатура функции и короткое пояснение на русском языке. **Документация позволяет понять, сколько аргументов у функции и какого они типа, возвращает ли что-то функция и если да, то какого типа возвращаемое значение.**

### Параметры по умолчанию

Рассмотрим **функцию round()**, которая округляет число с плавающей точкой:

`const result = round(10.25, 0); // 10`

Мы **передали в нее два параметра**: число, которое нужно округлить, и точность округления. 0 означает, что округление будет до ближайшего целого значения.

Чаще всего нужно округлять именно до целого числа (а не до десятых, например), поэтому создатели функции round() сделали второй параметр необязательным и задали ему внутри функции значение по умолчанию 0. **Значит, можно не указывать второй параметр, а результат будет тем же:**

`const result = round(10.25); // 10`

Если нужна другая точность, то можно передать параметр:

`// округление до одного знака после запятой`

`const result = round(10.25, 1); // 10.3`


Если функция в JavaScript принимает необязательные параметры, то они всегда стоят после обязательных. Их количество может быть любым (это зависит от самой функции), но они всегда идут рядом и в конце списка аргументов.